local WindowStateEventArgs = require("LuaFramework.Views.WindowStateEventArgs")
local AsyncResult = require("LuaFramework.CSharpObject.AsyncResult")
local Messenger = require("LuaFramework.Messaging.Messenger")

local WindowView = class("WindowView")

WindowView.__getter.Messenger = function (this, k)
    return this.messenger
end

WindowView.__getter.WindowManager = function (this, k)
    return WindowManager.Ins()
end

WindowView.__setter.ActivatedChanged = function (this, k, v)
    if v and v.callback ~= nil then
        table.insert(this.activatedChanged, v)
    else
        for i, value in ipairs(this.activatedChanged) do
            if v.this == value.this then
                table.remove(this.activatedChanged, i)
                break
            end
        end
    end
end

WindowView.__setter.VisibilityChanged = function (this, k, v)
    if v and v.callback ~= nil then
        table.insert(this.visibilityChanged, v)
    else
        for i, value in ipairs(this.visibilityChanged) do
            if v.this == value.this then
                table.remove(this.visibilityChanged, i)
                break
            end
        end
    end
end

WindowView.__setter.OnDismissed = function (this, k, v)
    if v and v.callback ~= nil then
        table.insert(this.onDismissed, v)
    else
        for i, value in ipairs(this.onDismissed) do
            if v.this == value.this then
                table.remove(this.onDismissed, i)
                break
            end
        end
    end
end

WindowView.__setter.StateChanged = function (this, k, v)
    if v and v.callback ~= nil then
        table.insert(this.stateChanged, v)
    else
        for i, value in ipairs(this.stateChanged) do
            if v.this == value.this then
                table.remove(this.stateChanged, i)
                break
            end
        end
    end
end

WindowView.__getter.Created = function (this, k, v)
    return this.created
end

WindowView.__getter.Dismissed = function (this, k, v)
    return this.dismissed
end

WindowView.__getter.Activated = function (this, k)
    return this.activated
end

WindowView.__setter.Activated = function (this, k, v)
    if v ~= this.activated then
        this.activated = v
        this:OnActivatedChanged()
        this:RaiseActivatedChanged()
    end
end

WindowView.__getter.State = function (this, k)
    return this.state
end

WindowView.__setter.State = function (this, k, v)
    if v ~= this.state then
        local old = this.state
        this.state = v
        this:RaiseStateChanged(old, this.state)
    end
end

WindowView.__getter.WindowType = function (this, k)
    return this.windowType
end

WindowView.__setter.WindowType = function (this, k, v)
    this.windowType = v
end

WindowView.__getter.WindowPriority = function (this, k)
    return this.windowPriority
end

WindowView.__setter.WindowPriority = function (this, k, v)
    if v < 0 then
        self.windowPriority = 0
    elseif v > 10 then
        self.windowPriority = 10
    else
        self.windowPriority = v
    end
end

WindowView.__getter.EnterAnimation = function (this, k)
    return this.enterAnimation
end

WindowView.__setter.EnterAnimation = function (this, k, v)
    this.enterAnimation = v
end

WindowView.__getter.ExitAnimation = function (this, k)
    return this.exitAnimation
end

WindowView.__setter.ExitAnimation = function (this, k ,v)
    this.exitAnimation = v
end

WindowView.__getter.Name = function (this, k)
    return this.gameObject and this.gameObject.name
end

WindowView.__setter.Name = function (this, k, v)
    if this.gameObject then
        this.gameObject.name = v
    end
end

WindowView.__getter.Parent = function (this, k)
    return this.parent
end

WindowView.__setter.Parent = function (this, k, v)
    this.parent = v
end

WindowView.__getter.Owner = function (this, k)
    return this.gameObject
end

WindowView.__setter.Owner = function (this, k, v)
    this.gameObject = v
end

WindowView.__getter.Transform = function (this, k)
    return this.transform
end

WindowView.__setter.Transform = function (this, k, v)
    this.transform = v
end

WindowView.__getter.Canvas = function (this, k)
    return this.canvas
end

WindowView.__setter.Canvas = function (this, k, v)
    this.canvas = v
end

WindowView.__getter.CanvasGroup = function (this, k)
    return this.canvasGroup
end

WindowView.__setter.CanvasGroup = function (this, k, v)
    this.canvasGroup = v
end

WindowView.__getter.Visibility = function (this, k)
    return this.gameObject and this.gameObject.activeSelf
end

WindowView.__setter.Visibility = function (this, k, v)
    if this.gameObject and v ~= this.gameObject.activeSelf then
        this.gameObject:SetActive(v)
    end
end

WindowView.__getter.Interactable = function (this, k)
    -- if this.gameObject then
    --     return this.CanvasGroup.interactable
    -- end
end

WindowView.__setter.Interactable = function (this, k, v)
    -- if this.gameObject then
    --     this.CanvasGroup.interactable = v
    -- end
end

WindowView.__getter.GraphicRaycaster = function (this, k)
    return this.graphicRaycaster
end

WindowView.__setter.GraphicRaycaster = function (this, k, v)
    this.graphicRaycaster = v
end

function WindowView:ctor(bundle)
    self.graphicRaycaster = nil
    self.canvasGroup = nil
    self.gameObject = nil
    self.transform = nil
    self.canvas = nil

    self.messenger = Messenger()
    self.windowManager = nil

    self.dismissTransition = nil
    self.enterAnimation = nil
    self.exitAnimation = nil

    self.created = false
    self.dismissed = false
    self.activated = false
    self.stateBroadcast = true
    self.windowPriority = 0
    self.windowType = WindowType.FULL
    self.state = WindowState.NONE
    
    self.activatedChanged = {}
    self.visibilityChanged = {}
    self.onDismissed = {}
    self.stateChanged = {}

    self.components = {}

    --
    self.parent = table.containskey(bundle, "parent") and bundle.parent
end

function WindowView:OnEnable()
    self:RaiseVisibilityChanged()
end

function WindowView:OnDisable()
    self:RaiseVisibilityChanged()
end

function WindowView:SetParent(parent)
    assert(parent, "")
    self.parent = parent
    self.transform:SetParent(parent)
end

function WindowView:OnActivatedChanged()
    self.Interactable = self.activated
end

function WindowView:RaiseActivatedChanged()
    try
    {
        function ()
            for i, v in ipairs(self.activatedChanged) do
                v.callback(v.this, self)
            end
        end
    }
end

function WindowView:RaiseVisibilityChanged()
    try
    {
        function ()
            for i, v in ipairs(self.visibilityChanged) do
                v.callback(v.this, self)
            end
        end
    }
end

function WindowView:RaiseOnDismissed()
    try
    {
        function ()
            for i, v in ipairs(self.onDismissed) do
                v.callback(v.this, self)
            end
        end
    }
end

function WindowView:RaiseStateChanged(oldState, newState)
    try
    {
        function ()
            local eventArgs = WindowStateEventArgs(self, oldState, newState)
            
            for i, v in ipairs(self.stateChanged) do
                v.callback(v.this, self, eventArgs)
            end
        end
    }
end

function WindowView:Activate(ignoreAnimation)
    local result = AsyncResult()
    try
    {
        function ()
            if not self.Visibility then
                return result
            end

            if self.Activated then
                result:SetResult()
                return result
            end

            if not ignoreAnimation and self.ActivationAnimation then
                self.ActivationAnimation:OnStart(function ()
                    self.State = WindowState.ACTIVATION_ANIMATION_BEGIN
                end):OnEnd(function ()
                    self.State = WindowState.ACTIVATION_ANIMATION_END
                    self.Activated = true
                    self.State = WindowState.ACTIVATED
                    result:SetResult()
                end):Play()
            else
                self.Activated = true
                self.State = WindowState.ACTIVATED
                result:SetResult()
            end
        end
    }
    return result
end

function WindowView:Passivate(ignoreAnimation)
    local result = AsyncResult()
    try
    {
        function ()
            if not self.Visibility then
                return result
            end

            if not self.Activated then
                result:SetResult()
                return result
            end

            self.Activated = false
            self.State = WindowState.PASSIVATED

            if not ignoreAnimation and self.ActivationAnimation then
                self.ActivationAnimation:OnStart(function ()
                    self.State = WindowState.PASSIVATION_ANIMATION_BEGIN
                end):OnEnd(function ()
                    self.State = WindowState.PASSIVATION_ANIMATION_END
                    result:SetResult()
                end):Play()
            else
                result:SetResult()
            end
        end
    }
    return result
end

function WindowView:Create(bundle)
    if self.dismissTransition or self.dismissed then
        return
    end

    if self.created then
        return
    end
    
    Executors.RunOnCoroutineNoReturn(Coroutine.Ins().GetEnumerator(function ()

        self.State = WindowState.CREATE_BEGIN

        local result = DefaultUIViewLocator.Ins():LoadAsync(self.prefabPath, typeof(CSharpType.GameObject))
        Coroutine.Ins().Yield(result:WaitForDone())
        print("加载完成。。。")

        self.Owner = result.Result
        self.Transform = self.Owner.transform
        self:SetParent(self.Parent or CSharpType.GameObject.Find("GameObject").transform)
        self.Transform.localPosition = CSharpType.Vector3.zero
        self.Transform.localRotation = CSharpType.Quaternion.identity
        self.Transform.localScale = CSharpType.Vector3.one

        --
        self:OnInit()
        
        self.Visibility = false
        self.Interactable = self.Activated
        self:OnCreate(bundle)
        self.WindowManager:Add(self)
        self.created = true
        self.State = WindowState.CREATE_END

        self:Show()
    end))
end

function WindowView:OnCreate()
    print("parent OnCreate")
end

function WindowView:Show(ignoreAnimation)
    if self.dismissTransition or self.dismissed then
        return
    end

    if self.Visibility then
        return
    end

    return self.WindowManager:Show(self):DisableAnimation(ignoreAnimation)
end

function WindowView:DoShow(ignoreAnimation)
    local result = AsyncResult()
    local action = function (promise)
        try
        {
            function ()
                if not self.created then
                    self:Create()
                end

                self:OnShow()
                self.Visibility = true
                self.State = WindowState.VISIBLE
                if not ignoreAnimation and self.EnterAnimation then
                    self.EnterAnimation:OnStart(function ()
                        self.State = WindowState.ENTER_ANIMATION_BEGIN
                    end):OnEnd(function ()
                        self.State = WindowState.ENTER_ANIMATION_END
                        promise:SetResult()
                    end):Play()
                else
                    promise:SetResult()
                end
            end
        }
    end
    action(result)
    return result
end

function WindowView:OnShow()
    print("parent OnShow")
end

function WindowView:Hide(ignoreAnimation)
    if not self.created then
        return
    end

    if self.dismissed then
        return
    end

    if not self.Visibility then
        return
    end

    return self.WindowManager:Hide(self):DisableAnimation(ignoreAnimation)
end

function WindowView:DoHide(ignoreAnimation)
    local result = AsyncResult()
    local action = function (promise)
        try
        {
            function ()
                if not ignoreAnimation and self.ExitAnimation then
                    self.ExitAnimation:OnStart(function ()
                        self.State = WindowState.EXIT_ANIMATION_BEGIN
                    end):OnEnd(function ()
                        self.State = WindowState.EXIT_ANIMATION_END
                        self.Visibility = false
                        self.State = WindowState.INVISIBLE
                        self:OnHide()
                        promise:SetResult()
                    end):Play()
                else
                    self.Visibility = false
                    self.State = WindowState.INVISIBLE
                    self:OnHide()
                    promise:SetResult()
                end
            end
        }
    end
    action(result)
    return result
end

function WindowView:OnHide()
    
end

function WindowView:Dismiss(ignoreAnimation)
    if self.dismissTransition then
        return self.dismissTransition
    end

    if self.dismissed then
        return
    end

    self.dismissTransition = self.WindowManager:Dismiss(self):DisableAnimation(ignoreAnimation)
    return self.dismissTransition
end

function WindowView:DoDismiss()
    try
    {
        function ()
            if not self.dismissed then
                self.State = WindowState.DISMISS_BEGIN
                self.dismissed = true
                self:OnDismiss()
                self:RaiseOnDismissed()
                self.WindowManager:Remove(self)

                if self.gameObject then
                    CSharpType.Object.Destroy(self.gameObject)
                end
                self.State = WindowState.DISMISS_END
                self.dismissTransition = nil
            end
        end
    }
end

function WindowView:OnDismiss()
    
end

function WindowView:OnDestroy()
    if not self.dismissed and not self.dismissTransition then
        self:Dismiss(true)
    end
    self.super:OnDestroy()

    local layer = LayerManager.Ins():GetLayer(self.layerName)
    layer:PopWindowOder()
end

function WindowView:OnInit()
    assert(self.Owner, "")

    self.Canvas = self:AddComponent(Canvas)
    self.CanvasGroup = self:AddComponent(CanvasGroup)
    self.GraphicRaycaster = self:AddComponent(GraphicRaycaster)

    local layer = LayerManager.Ins():GetLayer(self.layerName)
    assert(layer, "")

    self.Canvas:SetOverrideSorting(true)
    self.Canvas:SetSortingOrder(layer:PushWindowOrder())
    self.CanvasGroup:SetAlpha(1)
end

function WindowView:GetComponent(name)
    local component = Canvas(self.variables[name])
    table.insert(self.components, component)
    return component
end

function WindowView:AddComponent(component)
    assert(self.gameObject, "")
    return component(self.gameObject:AddComponent(component.CSharpType))
end

function WindowView:Destroy()
    for i, v in ipairs(self.components) do
        v:Destroy()
    end
    self.components = nil
end

--[[
    ViewStack {1,2,3}

    -- 堆栈同层互斥
    Manager.Current.ViewStack
    for i, v in ipairs(Manager.Current.ViewStack) do
        
    end

    for i = #(Manager.Current.ViewStack), 1, -1 do
        if Manager.Current.ViewStack[i].layer == WindowView.layer then
            local v = table.remove(self.ViewStack, i)
            v:OnDestroy()
        end
    end
]]

return WindowView