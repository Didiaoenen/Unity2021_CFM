local ViewGroup = require("LuaFramework.Views.ViewGroup")

local CoroutineExt = require("LuaFramework.Common.CoroutineExt")
local Miscellaneous = require("LuaFramework.Common.Miscellaneous")
local ListExtention = require("LuaFramework.Common.ListExtention")
local ExecutorsExt = require("LuaFramework.Execution.ExecutorsExt")
local DefaultUIViewLocator = require("LuaFramework.Views.Locators.DefaultUIViewLocator")

local WindowEnum = require("LuaFramework.Views.WindowEnum")
local Messenger = require("LuaFramework.Messaging.Messenger")
local AsyncResultExt = require("LuaFramework.Asynchronous.AsyncResultExt")
local WindowStateEventArgs = require("LuaFramework.Views.WindowStateEventArgs")

local CanvasExt = require("LuaFramework.Views.Components.CanvasExt")
local GameObjectExt = require("LuaFramework.Views.Components.GameObjectExt")
local CanvasGroupExt = require("LuaFramework.Views.Components.CanvasGroupExt")
local RectTransformExt = require("LuaFramework.Views.Components.RectTransformExt")
local GraphicRaycasterExt = require("LuaFramework.Views.Components.GraphicRaycasterExt")
local MonoVariableArrayExt = require("LuaFramework.Views.Components.MonoVariableArrayExt")

local WindowManager = require("LuaFramework.Views.WindowManager")

local ViewBase = class("ViewBase", ViewGroup)

ViewBase.PrefabPath = ""

function ViewBase.get:Messenger()
   return self.messenger
end

function ViewBase.set:ActivatedChanged(value)
   setcallback(self.activatedChanged, value)
end

function ViewBase.set:VisibilityChanged(value)
   setcallback(self.visibilityChanged, value)
end

function ViewBase.set:OnDismissed(value)
   setcallback(self.onDismissed, value)
end

function ViewBase.set:StateChanged(value)
   setcallback(self.stateChanged, value)
end

function ViewBase.get:Created()
   return self.created
end

function ViewBase.get:Dismissed()
   return self.dismissed
end

function ViewBase.get:Activated()
   return self.activated
end

function ViewBase.set:Activated(value)
   if value ~= self.activated then
      self.activated = value
      self:RaiseActivatedChanged()
   end
end

function ViewBase.get:State()
   return self.state
end

function ViewBase.set:State(value)
   if value ~= self.state then
      local old = self.state
      self.state = value
      self:RaiseStateChanged(old, self.state)
   end
end

function ViewBase.get:WindowType()
   return self.windowType
end

function ViewBase.get:EnterAnimation()
   return self.enterAnimation
end

function ViewBase.set:EnterAnimation(value)
   self.enterAnimation = value
end

function ViewBase.get:ExitAnimation()
   return self.exitAnimation
end

function ViewBase.set:ExitAnimation(value)
   self.exitAnimation = value
end

function ViewBase.get:Name()
   assert(self.gameObject, "")
   return self.gameObject.name
end

function ViewBase.get:Parent()
   return self.parent
end

function ViewBase.get:Owner()
   return self.gameObject
end

function ViewBase.get:Transform()
   return self.transform
end

function ViewBase.get:Visibility()
   assert(self.viewModel, "")
   return self.viewModel.ActiveSelf
end

function ViewBase.set:Visibility(value)
   if not self.viewModel then
      return
   end

   if self.viewModel.ActiveSelf == value then
      return
   end

   self.viewModel.ActiveSelf = value
end

function ViewBase:ctor(bundle)
   ViewGroup.ctor(self)

   self.bundle = bundle

   self.messenger = Messenger.new()

   self.gameObject = nil
   self.transform = nil

   self.dismissTransition = nil
   self.enterAnimation = nil
   self.exitAnimation = nil

   self.mutex = true
   self.created = false
   self.dismissed = false
   self.activated = false
   self.stateBroadcast = true
   self.windowType = WindowEnum.WindowType.NONE
   self.state = WindowEnum.WindowState.NONE

   self.activatedChanged = {}
   self.visibilityChanged = {}
   self.onDismissed = {}
   self.stateChanged = {}

   self.viewModel = nil
   self.bindingExt = nil
   self.bindingSet = nil

   self.parent = nil
   self.variables = nil
   self.components = {}
   self.gameObjects = {}
end

function ViewBase:OnEnable()
   self:RaiseVisibilityChanged()
end

function ViewBase:OnDisable()
   self:RaiseVisibilityChanged()
end

function ViewBase:RaiseActivatedChanged()
   ListExtention.Foreach(self.activatedChanged, function(_, v)
      v.callback(v.this, self)
   end)
end

function ViewBase:RaiseVisibilityChanged()
   ListExtention.Foreach(self.visibilityChanged, function(_, v)
      v.callback(v.this, self)
   end)
end

function ViewBase:RaiseOnDismissed()
   ListExtention.Foreach(self.onDismissed, function(_, v)
      v.callback(v.this, self)
   end)
end

function ViewBase:RaiseStateChanged(oldState, newState)
   local eventArgs = WindowStateEventArgs.new(self, oldState, newState)
   ListExtention.Foreach(self.stateChanged, function(_, v)
      v.callback(v.this, self, eventArgs)
   end)
end

function ViewBase:Activate(ignoreAnimation)
   local result = AsyncResultExt.new()

   if not self.Visibility then
      return result
   end

   if self.Activated then
      result:SetResult()
      return result
   end

   if not ignoreAnimation and self.ActivationAnimation then
      self.ActivationAnimation:OnStart(function()
         self.State = WindowEnum.WindowState.ACTIVATION_ANIMATION_BEGIN
      end):OnEnd(function()
         self.State = WindowEnum.WindowState.ACTIVATION_ANIMATION_END
         self.Activated = true
         self.State = WindowEnum.WindowState.ACTIVATED
         result:SetResult()
      end):Play()
   else
      self.Activated = true
      self.State = WindowEnum.WindowState.ACTIVATED
      result:SetResult()
   end

   return result
end

function ViewBase:Passivate(ignoreAnimation)
   local result = AsyncResultExt.new()

   if not self.Visibility then
      return result
   end

   if not self.Activated then
      result:SetResult()
      return result
   end

   self.Activated = false
   self.State = WindowEnum.WindowState.PASSIVATED

   if not ignoreAnimation and self.ActivationAnimation then
      self.ActivationAnimation:OnStart(function()
         self.State = WindowEnum.WindowState.PASSIVATION_ANIMATION_BEGIN
      end):OnEnd(function()
         self.State = WindowEnum.WindowState.PASSIVATION_ANIMATION_END
         result:SetResult()
      end):Play()
   else
      result:SetResult()
   end

   return result
end

function ViewBase:Create()
   if self.dismissTransition or self.dismissed then
      return
   end

   if self.created then
      return
   end

   ExecutorsExt.Instance:RunOnCoroutineNoReturn(CoroutineExt.GetEnumerator(function()

      self.State = WindowEnum.WindowState.CREATE_BEGIN
      self.Visibility = false

      local result = DefaultUIViewLocator.LoadAsync(self.PrefabPath, Miscellaneous.CSType.GameObjectT)
      CoroutineExt.Yield(result:WaitForDone())
      print("加载完成。。。")

      self.gameObject = GameObjectExt.new(result.Result)

      self:OnCreate()
      self.created = true
      self.State = WindowEnum.WindowState.CREATE_END

      self:Show()
   end))
end

function ViewBase:OnCreate()
   print("parent OnCreate")

   self.parent = self.viewModel.parent

   self.variables = self:GetComponent(MonoVariableArrayExt)

   local bindingSet = self.bindingSet


   local builder = bindingSet:BindByTarget(self.gameObject)
   builder:For(self.gameObject.ActiveSelf):To("ActiveSelf"):OneWay()


   self.transform = self:GetComponent(RectTransformExt)
   builder = bindingSet:BindByTarget(self.transform)
   builder:For(self.transform.Parent):To("Parent"):OneWay()

   builder = bindingSet:BindByTarget(self.transform)
   builder:For(self.transform.LocalRotation):To("LocalRotation"):OneWay()

   builder = bindingSet:BindByTarget(self.transform)
   builder:For(self.transform.LocalPosition):To("LocalPosition"):OneWay()

   builder = bindingSet:BindByTarget(self.transform)
   builder:For(self.transform.LocalScale):To("LocalScale"):OneWay()

   builder = bindingSet:BindByTarget(self.transform)
   builder:For((self.transform).OffsetMax):To("OffsetMax"):OneWay()

   builder = bindingSet:BindByTarget(self.transform)
   builder:For((self.transform).OffsetMin):To("OffsetMin"):OneWay()


   local canvas = self:AddComponent(CanvasExt)
   builder = bindingSet:BindByTarget(canvas.handler)
   builder:For(canvas.OverrideSorting):To("OverrideSorting"):OneWay()

   builder = bindingSet:BindByTarget(canvas.handler)
   builder:For(canvas.SortingOrder):To("SortingOrder"):OneWay()


   local canvasGroup = self:AddComponent(CanvasGroupExt)
   builder = bindingSet:BindByTarget(canvasGroup.handler)
   builder:For(canvasGroup.Alpha):To("Alpha"):OneWay()


   self:AddComponent(GraphicRaycasterExt)

   self.bindingSet:Build()


   local layer = WindowManager.Instance:GetLayer(self.windowType)
   assert(layer, "")

   self.viewModel.SortingOrder = layer:PushWindowOrder()
end

function ViewBase:Show(ignoreAnimation)
   if self.dismissTransition or self.dismissed then
      return
   end

   if self.Visibility then
      return
   end

   return WindowManager.Instance:Show(self):DisableAnimation(ignoreAnimation)
end

function ViewBase:DoShow(ignoreAnimation)
   local result = AsyncResultExt.new()
   local action = function(promise)
      if not self.created then
         self:Create()
      end

      self:OnShow()
      self.Visibility = true
      self.State = WindowEnum.WindowState.VISIBLE
      if not ignoreAnimation and self.EnterAnimation then
         self.EnterAnimation:OnStart(function()
            self.State = WindowEnum.WindowState.ENTER_ANIMATION_BEGIN
         end):OnEnd(function()
            self.State = WindowEnum.WindowState.ENTER_ANIMATION_END
            promise:SetResult()
         end):Play()
      else
         promise:SetResult()
      end
   end
   action(result)
   return result
end

function ViewBase:OnShow()
   print("parent OnShow")
end

function ViewBase:Hide(ignoreAnimation)
   if not self.created then
      return
   end

   if self.dismissed then
      return
   end

   if not self.Visibility then
      return
   end

   return WindowManager.Instance:Hide(self):DisableAnimation(ignoreAnimation)
end

function ViewBase:DoHide(ignoreAnimation)
   local result = AsyncResultExt.new()
   local action = function(promise)
      if not ignoreAnimation and self.ExitAnimation then
         self.ExitAnimation:OnStart(function()
            self.State = WindowEnum.WindowState.EXIT_ANIMATION_BEGIN
         end):OnEnd(function()
            self.State = WindowEnum.WindowState.EXIT_ANIMATION_END
            self.Visibility = false
            self.State = WindowEnum.WindowState.INVISIBLE
            self:OnHide()
            promise:SetResult()
         end):Play()
      else
         self.Visibility = false
         self.State = WindowEnum.WindowState.INVISIBLE
         self:OnHide()
         promise:SetResult()
      end
   end
   action(result)
   return result
end

function ViewBase:OnHide()

end

function ViewBase:Dismiss(ignoreAnimation)
   if self.dismissTransition then
      return self.dismissTransition
   end

   if self.dismissed then
      return
   end

   self.dismissTransition = WindowManager.Instance:Dismiss(self):DisableAnimation(ignoreAnimation)
   return self.dismissTransition
end

function ViewBase:DoDismiss()
   if not self.dismissed then
      assert(self.gameObject, "")
      self.State = WindowEnum.WindowState.DISMISS_BEGIN
      self.dismissed = true
      self:OnDismiss()
      self:RaiseOnDismissed()
      CS.UnityEngine.Object.Destroy(self.gameObject.handler)
      self.State = WindowEnum.WindowState.DISMISS_END
      self.dismissTransition = nil
   end
end

function ViewBase:OnDismiss()

end

function ViewBase:GetComponentWithName(component, name)
   assert(component and name, "")
   component = component.new(self.variables:Get(name))
   table.insert(self.components, component)
   return component
end

function ViewBase:GetGameObjectWithName(gameObject, name)
   assert(gameObject and name, "")
   gameObject = gameObject.new(self.variables:Get(name))
   table.insert(self.gameObjects, gameObject)
   return gameObject
end

function ViewBase:GetComponent(component)
   assert(self.gameObject, "")
   return component.new(self.gameObject:GetComponent(typeof(component.CSObject)))
end

function ViewBase:AddComponent(component)
   assert(self.gameObject, "")
   return component.new(self.gameObject:AddComponent(typeof(component.CSObject)))
end

function ViewBase:GetView(name)
   assert({ name }, "")
end

function ViewBase:AddView(name, parent)
   assert({ name, parent }, "")
end

function ViewBase:RemoveView(name)
   assert({ name }, "")
end

function ViewBase:dtor()
   if not self.dismissed and not self.dismissTransition then
      self:Dismiss(true)
   end

   ListExtention.Foreach(self.components, function(_, v)
      v:delete()
   end)
   self.components = nil

   local layer = WindowManager.Instance:GetLayer(self.windowType)
   layer:PopWindowOder()
end

return ViewBase
