local Layer = require("Luaframework.Views.Layer")
local TransitionShow = require("Luaframework.Views.TransitionShow")
local TransitionHide = require("Luaframework.Views.TransitionHide")
local TransitionExecutor = require("Luaframework.Views.TransitionExecutor")

local WindowManager = class("WindowManager")

local layers = {
	{WindowType = WindowType.NONE, OrderInLayer = 0, OrderStep = 10},
	{WindowType = WindowType.FULL, OrderInLayer = 1000, OrderStep = 10},
	{WindowType = WindowType.POPUP, OrderInLayer = 2000, OrderStep = 10},
	{WindowType = WindowType.DIALOG, OrderInLayer = 3000, OrderStep = 10},
	{WindowType = WindowType.PROGRESS, OrderInLayer = 4000, OrderStep = 10},
	{WindowType = WindowType.QUEUED_POPUP, OrderInLayer = 5000, OrderStep = 10},
}

local blockingExecutor = nil

local GetTransitionExecutor = function ()
    if not blockingExecutor then
        blockingExecutor = TransitionExecutor()
    end
    return blockingExecutor
end

function WindowManager.get:Current()
    return self.windowStack[#(self.windowStack)]
end

function WindowManager:ctor()
    self.current = nil

    self.layers = {}
    self.windowViews = {}
    self.windowStack = {}
    self.hideWindows = {}

    self:CreateLayers()
end

function WindowManager:OnEnable()

end

function WindowManager:OnDisable()

end

function WindowManager:OnDestroy()

end

function WindowManager:Show(window)
    local transition = TransitionShow(self, window)
    GetTransitionExecutor():Execute(transition)
    return transition:OnStateChanged(function (w, state)
        if state == WindowState.VISIBLE then
        end
    end)
end

function WindowManager:Hide(window)
    local transition = TransitionHide(self, window, false)
    GetTransitionExecutor():Execute(transition)
    return transition:OnStateChanged(function (w, state)
        if state == WindowState.INVISIBLE then
        end
    end)
end

function WindowManager:Dismiss(window)
    local transition = TransitionHide(self, window, true)
    GetTransitionExecutor():Execute(transition)
    return transition:OnStateChanged(function (w, state)
        if state == WindowState.INVISIBLE then
        end
    end)
end

function WindowManager:PushWindowStack(window)
    if self.Current ~= self.windowStack[1] then
        local window = table.remove(self.windowStack, #(self.windowStack))
        window:Hide()
    end
    table.insert(self.windowStack, window)
end

function WindowManager:PopWindowStack()
    assert(#(self.windowStack) > 0, "")
    local window = table.remove(self.windowStack, #(self.windowStack))
    window:Hide()
    return self.Current and self.Current:Show()
end

function WindowManager:Open(name, bundle)
    local window = require(name)
    window(bundle):Create()

    if window.windowType == WindowType.NONE then
        self.Current:AddSubView(window)
    elseif window.windowType == WindowType.FULL then
        self:PushWindowStack(window)
    elseif window.windowType == WindowType.POPUP or window.windowType == WindowType.DIALOG then
        self.Current:PushOpenView(window)
    end
    table.insert(self.windowViews, window)

    return window
end

function WindowManager:Close(name)
    local window = self:GetWindowView(name)
    if window.windowType == WindowType.NONE then
        window:Hide()
    elseif window.windowType == WindowType.FULL then
        self:PopWindowStack()
    elseif window.windowType == WindowType.POPUP or window.windowType == WindowType.DIALOG then
        self.Current:PopOpenView()
    end
end

function WindowManager:GetWindowView(name)
    table.find(self.windowViews, function (i, v)
        return v.Name == name
    end)
end

function WindowManager:CreateLayers()
    for i, v in ipairs(layers) do
        local layer = Layer(v)
        table.insert(self.layers, layer)
    end    
end

function WindowManager:GetLayer(windowType)
    return table.find(self.layers, function (i, v)
        return v.WindowType == windowType
    end)
end

function WindowManager:__singleton()
    return WindowManager.new()
end

function WindowManager:dtor()
    
end

return WindowManager